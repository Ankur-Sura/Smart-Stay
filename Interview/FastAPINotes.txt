===================================================================================
                    ⚡ FASTAPI - COMPLETE STUDY NOTES
===================================================================================

                        For Smart Stay Project
                        Python AI Backend Service

===================================================================================
                         CHAPTER 1: WHAT IS FASTAPI?
===================================================================================

DEFINITION:
-----------
FastAPI is a modern, fast Python web framework for building APIs.
It's based on Python type hints and provides automatic validation.

KEY FEATURES:
------------
1. FAST: One of the fastest Python frameworks (on par with Node.js/Go)
2. Easy: Intuitive to use with Python type hints
3. Automatic docs: Swagger UI and ReDoc out of the box
4. Validation: Automatic request/response validation with Pydantic
5. Async: Built-in async/await support

WHY FASTAPI FOR SMART STAY?
--------------------------
1. Python ecosystem: LangGraph, OpenAI, NLP libraries
2. Automatic API docs: Easy to test AI endpoints
3. Pydantic: Strong typing for AI request/response
4. Async: Handle multiple AI requests efficiently
5. Clean code: Type hints make AI logic readable

===================================================================================
                         CHAPTER 2: BASIC STRUCTURE
===================================================================================

MINIMAL FASTAPI APP:
-------------------
    from fastapi import FastAPI
    
    app = FastAPI()
    
    @app.get("/")
    def read_root():
        return {"message": "Hello World"}
    
    @app.get("/items/{item_id}")
    def read_item(item_id: int):
        return {"item_id": item_id}

To run:
    uvicorn main:app --reload --port 8000

Access:
    http://localhost:8000        → API
    http://localhost:8000/docs   → Swagger UI (SUPER USEFUL!)


SMART STAY STRUCTURE:
--------------------
    AI/
    ├── main.py              # FastAPI app entry
    ├── agent_service.py     # AI agent logic
    ├── travel_graph.py      # Travel planner workflow
    ├── solo_trip_graph.py   # Solo trip HITL workflow
    ├── tools_service.py     # Search & utility tools
    └── requirements.txt     # Python dependencies

===================================================================================
                         CHAPTER 3: ROUTERS & ORGANIZATION
===================================================================================

WHAT ARE ROUTERS?
----------------
Routers help organize endpoints into logical groups.
Like Express's router, but with more structure.

CREATING A ROUTER:
-----------------
    # agent_service.py
    from fastapi import APIRouter
    
    router = APIRouter(
        prefix="/agent",      # All routes start with /agent
        tags=["AI Agent"]     # Group in docs
    )
    
    @router.post("/travel-planner")
    async def plan_travel(request: TravelRequest):
        return {"plan": "..."}
    
    @router.post("/solo-trip")
    async def solo_trip(request: SoloTripRequest):
        return {"trip": "..."}


INCLUDING ROUTER IN APP:
-----------------------
    # main.py
    from fastapi import FastAPI
    from agent_service import router as agent_router
    
    app = FastAPI(
        title="Smart Stay AI Service",
        description="AI backend for travel planning"
    )
    
    # Include router
    app.include_router(agent_router)
    
    # Now these work:
    # POST /agent/travel-planner
    # POST /agent/solo-trip

===================================================================================
                         CHAPTER 4: PYDANTIC MODELS
===================================================================================

WHAT IS PYDANTIC?
----------------
Pydantic provides data validation using Python type hints.
FastAPI uses it for request/response models.

DEFINING MODELS:
---------------
    from pydantic import BaseModel
    from typing import Optional, List
    
    class TravelRequest(BaseModel):
        query: str
        source: Optional[str] = None
        destination: Optional[str] = None
        preferences: Optional[dict] = None
    
    class TravelResponse(BaseModel):
        status: str
        destination_info: dict
        transport: List[dict]
        hotels: List[dict]
        activities: List[dict]
        final_packages: List[dict]


USING IN ENDPOINTS:
------------------
    @router.post("/travel-planner", response_model=TravelResponse)
    async def plan_travel(request: TravelRequest):
        # request is automatically validated
        # response is automatically validated
        return result


VALIDATION EXAMPLE:
------------------
    class UserPreferences(BaseModel):
        travel_mode: str
        budget: int  # Must be integer
        food_preference: str
    
    # This request would FAIL validation:
    # {"travel_mode": "car", "budget": "expensive", "food_preference": "veg"}
    # Because "expensive" is not an integer!
    
    # FastAPI returns automatic error:
    # {"detail": [{"msg": "value is not a valid integer"}]}

===================================================================================
                         CHAPTER 5: REQUEST HANDLING
===================================================================================

PATH PARAMETERS:
---------------
    @app.get("/listings/{listing_id}")
    def get_listing(listing_id: str):
        # listing_id extracted from URL
        return {"id": listing_id}


QUERY PARAMETERS:
----------------
    @app.get("/search")
    def search(
        location: str,                    # Required
        min_price: int = 0,               # Optional with default
        max_price: int = 100000,
        limit: Optional[int] = None       # Optional, None if not provided
    ):
        return {"location": location, "price_range": [min_price, max_price]}
    
    # GET /search?location=Goa&min_price=1000&max_price=5000


REQUEST BODY:
------------
    class SearchRequest(BaseModel):
        location: str
        filters: dict
    
    @app.post("/search")
    def search(request: SearchRequest):
        # Automatically parsed from JSON body
        return {"location": request.location}


COMBINING ALL:
-------------
    @app.post("/listings/{category}/search")
    def search(
        category: str,                    # Path parameter
        sort_by: str = "price",           # Query parameter
        request: SearchRequest = None     # Request body
    ):
        return {
            "category": category,
            "sort": sort_by,
            "filters": request.filters
        }

===================================================================================
                         CHAPTER 6: ASYNC OPERATIONS
===================================================================================

WHY ASYNC?
---------
AI operations (OpenAI calls, web search) are I/O bound.
Async lets server handle other requests while waiting.

SYNC VS ASYNC:
-------------
    # Sync - blocks while waiting
    @app.post("/sync")
    def sync_endpoint():
        result = slow_ai_call()  # Server blocked
        return result
    
    # Async - doesn't block
    @app.post("/async")
    async def async_endpoint():
        result = await slow_ai_call()  # Other requests can process
        return result


RUNNING SYNC CODE IN ASYNC:
--------------------------
LangGraph invoke is synchronous. Use asyncio.to_thread:

    import asyncio
    
    @router.post("/travel-planner")
    async def plan_travel(request: TravelRequest):
        # Run sync function in thread pool
        result = await asyncio.to_thread(
            travel_graph.invoke,
            {"query": request.query}
        )
        return result


CONCURRENT CALLS:
----------------
    async def get_weather_and_news(city: str):
        # Run both concurrently
        weather_task = asyncio.create_task(get_weather(city))
        news_task = asyncio.create_task(get_news(city))
        
        weather = await weather_task
        news = await news_task
        
        return {"weather": weather, "news": news}

===================================================================================
                         CHAPTER 7: ERROR HANDLING
===================================================================================

HTTP EXCEPTIONS:
---------------
    from fastapi import HTTPException
    
    @app.get("/listings/{listing_id}")
    def get_listing(listing_id: str):
        listing = db.find(listing_id)
        if not listing:
            raise HTTPException(
                status_code=404,
                detail=f"Listing {listing_id} not found"
            )
        return listing


GLOBAL ERROR HANDLER:
--------------------
    from fastapi import Request
    from fastapi.responses import JSONResponse
    
    @app.exception_handler(Exception)
    async def global_exception_handler(request: Request, exc: Exception):
        return JSONResponse(
            status_code=500,
            content={
                "error": "Internal server error",
                "detail": str(exc)
            }
        )


TRY-EXCEPT IN ENDPOINTS:
-----------------------
    @router.post("/travel-planner")
    async def plan_travel(request: TravelRequest):
        try:
            result = await asyncio.to_thread(
                travel_graph.invoke,
                {"query": request.query}
            )
            return result
        except openai.RateLimitError:
            raise HTTPException(
                status_code=429,
                detail="AI service rate limited. Please try again."
            )
        except Exception as e:
            raise HTTPException(
                status_code=500,
                detail=f"Planning failed: {str(e)}"
            )

===================================================================================
                         CHAPTER 8: CORS & MIDDLEWARE
===================================================================================

WHAT IS CORS?
------------
Cross-Origin Resource Sharing - allows frontend (localhost:8080)
to call backend (localhost:8000).

ENABLING CORS:
-------------
    from fastapi.middleware.cors import CORSMiddleware
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["http://localhost:8080"],  # Express server
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"]
    )


CUSTOM MIDDLEWARE:
-----------------
    from fastapi import Request
    import time
    
    @app.middleware("http")
    async def log_requests(request: Request, call_next):
        start = time.time()
        response = await call_next(request)
        duration = time.time() - start
        print(f"{request.method} {request.url.path} - {duration:.2f}s")
        return response

===================================================================================
                         CHAPTER 9: IN SMART STAY
===================================================================================

MAIN.PY STRUCTURE:
-----------------
    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware
    from agent_service import router as agent_router
    from tools_service import router as tools_router
    
    app = FastAPI(
        title="Smart Stay AI Service",
        description="AI backend for hotel booking platform"
    )
    
    # CORS for Express communication
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"]
    )
    
    # Include routers
    app.include_router(agent_router)
    app.include_router(tools_router)
    
    # Health check
    @app.get("/health")
    def health():
        return {"status": "healthy"}


KEY ENDPOINTS:
-------------
    POST /agent/travel-planner    → 8-node workflow
    POST /agent/solo-trip         → 11-node HITL workflow
    POST /agent/chat              → Smart chat
    POST /tools/extract-amenities → NLP extraction
    POST /tools/search            → Web search
    GET  /health                  → Health check

===================================================================================
                         CHAPTER 10: TESTING & DOCS
===================================================================================

AUTOMATIC SWAGGER UI:
--------------------
Access at: http://localhost:8000/docs

Features:
- See all endpoints
- Try endpoints directly
- See request/response schemas
- Interactive testing


TESTING WITH CURL:
-----------------
    curl -X POST "http://localhost:8000/agent/travel-planner" \
         -H "Content-Type: application/json" \
         -d '{"query": "Plan trip to Goa"}'


TESTING WITH PYTHON:
-------------------
    import requests
    
    response = requests.post(
        "http://localhost:8000/agent/travel-planner",
        json={"query": "Plan trip to Goa"}
    )
    print(response.json())

===================================================================================
                         CHAPTER 11: INTERVIEW ANSWERS
===================================================================================

Q: Why FastAPI instead of Flask?
A: "FastAPI provides automatic validation with Pydantic, built-in
    async support for AI operations, and automatic API documentation.
    Flask would require adding these manually."

Q: How does FastAPI handle validation?
A: "FastAPI uses Pydantic models. When I define a request model
    with type hints, FastAPI automatically validates incoming
    requests and returns detailed errors if validation fails."

Q: How does Express communicate with FastAPI?
A: "Express makes HTTP POST requests using fetch() to FastAPI
    endpoints on port 8000. Request and response bodies are JSON.
    FastAPI validates incoming requests, processes them through
    LangGraph workflows, and returns structured responses."

Q: What's the advantage of routers?
A: "Routers organize related endpoints together. I have an agent
    router for AI workflows and a tools router for utilities.
    This makes code maintainable and generates clean API docs."

===================================================================================
                              KEY TAKEAWAYS
===================================================================================

1. FastAPI = Modern Python web framework with auto-validation
2. Pydantic = Type-safe request/response models
3. Routers = Organize endpoints into logical groups
4. Async = Non-blocking for AI operations
5. Swagger = Auto-generated docs at /docs
6. HTTPException = Clean error handling

REMEMBER: FastAPI + Pydantic = Type safety for Python APIs
          Perfect for AI services needing structured data.

===================================================================================

