===================================================================================
                    ðŸ”„ HUMAN-IN-THE-LOOP (HITL) - COMPLETE GUIDE
===================================================================================

                        For Smart Stay Project
                        Solo Trip Planner Feature

===================================================================================
                         CHAPTER 1: WHAT IS HITL?
===================================================================================

DEFINITION:
-----------
Human-in-the-Loop (HITL) is a design pattern where an AI workflow
PAUSES execution to get input from a human user before continuing.

SIMPLE ANALOGY:
--------------
Traditional AI: Autopilot - flies from A to B without asking
HITL AI: GPS navigation - "Turn left or take highway?" then continues

WHY HITL?
---------
1. Personalization: AI can't guess preferences
2. Validation: Human confirms critical decisions
3. Clarification: Ambiguous queries need human input
4. Control: Human stays in the loop, not replaced

REAL EXAMPLE (Smart Stay):
-------------------------
Without HITL:
    User: "Plan a solo trip to Manali"
    AI: *assumes everything* â†’ Generic plan
    
With HITL:
    User: "Plan a solo trip to Manali"
    AI: "How do you prefer to travel? Car/Train/Bus/Flight"
    User: "Car - I have an EV"
    AI: "What's your food preference? Veg/Non-veg/Vegan"
    User: "Vegetarian"
    AI: "Budget? Budget/Mid-range/Luxury"
    User: "Mid-range"
    AI: â†’ Personalized plan with EV charging stops, veg restaurants, mid-range hotels

===================================================================================
                         CHAPTER 2: LANGGRAPH HITL FUNCTIONS
===================================================================================

FUNCTION 1: interrupt(value)
---------------------------
What: Pauses the workflow and returns a value to the user
When: At decision points where human input is needed
Returns: Whatever the user responds with

    from langgraph.types import interrupt
    
    def ask_preference_node(state):
        # This PAUSES the workflow
        answer = interrupt({
            "question": "What is your food preference?",
            "options": ["Vegetarian", "Non-vegetarian", "Vegan"]
        })
        
        # This runs AFTER user responds
        return {"food_preference": answer}

IMPORTANT: Code after interrupt() only runs when workflow resumes!


FUNCTION 2: Command(resume=value)
--------------------------------
What: Resumes a paused workflow with user's answer
When: After user provides input
How:
    from langgraph.types import Command
    
    # Resume with user's answer
    result = graph.invoke(
        Command(resume="Vegetarian"),  # User's answer
        config={"configurable": {"thread_id": "session123"}}
    )


THE FLOW:
--------
1. Graph runs until interrupt()
2. interrupt() returns question to user
3. User sees question, provides answer
4. Backend calls Command(resume=answer)
5. Graph resumes from after interrupt()
6. Continues until next interrupt() or END

===================================================================================
                         CHAPTER 3: STATE PERSISTENCE
===================================================================================

WHY PERSISTENCE?
---------------
Without persistence:
    - User answers question
    - Closes browser
    - Opens again
    - Lost! Must start over

With persistence:
    - User answers question
    - Closes browser
    - Opens again (even days later)
    - Continues from where they left off!


MONGODB CHECKPOINTING:
---------------------
LangGraph can save state to MongoDB:

    from langgraph.checkpoint.mongodb import MongoDBSaver
    
    # Create checkpointer
    checkpointer = MongoDBSaver(
        uri="mongodb://127.0.0.1:27017",
        db_name="smartstay",
        collection_name="langgraph_checkpoints"
    )
    
    # Compile graph WITH checkpointer
    app = graph.compile(checkpointer=checkpointer)


THREAD_ID - The Magic Key:
-------------------------
thread_id uniquely identifies a conversation/session

    # Starting a new conversation
    result = app.invoke(
        {"query": "Plan trip to Goa"},
        config={"configurable": {"thread_id": "user123_trip1"}}
    )
    
    # Resuming the SAME conversation
    result = app.invoke(
        Command(resume="Vegetarian"),
        config={"configurable": {"thread_id": "user123_trip1"}}  # Same ID!
    )
    
    # Starting a DIFFERENT conversation
    result = app.invoke(
        {"query": "Plan trip to Kerala"},
        config={"configurable": {"thread_id": "user123_trip2"}}  # Different ID
    )


WHAT GETS SAVED:
---------------
- Current state (all accumulated data)
- Which node we're at
- Conversation history
- Timestamp

===================================================================================
                         CHAPTER 4: IMPLEMENTATION IN SMART STAY
===================================================================================

SOLO TRIP PLANNER - 11 NODE HITL WORKFLOW:
-----------------------------------------

Nodes 1: extract_details (automatic)
    - Extracts trip details from query
    - No human input needed

Nodes 2-5: ask_* nodes (HITL)
    - ask_travel_mode â†’ interrupt() â†’ User answers â†’ resume
    - ask_food_preference â†’ interrupt() â†’ User answers â†’ resume  
    - ask_budget â†’ interrupt() â†’ User answers â†’ resume
    - ask_accommodation â†’ interrupt() â†’ User answers â†’ resume

Nodes 6-10: planning nodes (automatic)
    - Use preferences from HITL nodes
    - Generate personalized plan

Node 11: create_itinerary (automatic)
    - Compile everything into final plan


CODE EXAMPLE - ASK NODE:
-----------------------
def ask_travel_mode(state: SoloTripState) -> dict:
    """
    Node 2: Ask user their preferred travel mode.
    Uses interrupt() to pause and wait for user input.
    """
    # Prepare question
    question = {
        "type": "preference_question",
        "question": "How do you prefer to travel?",
        "options": [
            {"value": "car_petrol", "label": "ðŸš— Car (Petrol/Diesel)"},
            {"value": "car_ev", "label": "âš¡ Car (Electric Vehicle)"},
            {"value": "train", "label": "ðŸš‚ Train"},
            {"value": "bus", "label": "ðŸšŒ Bus"},
            {"value": "flight", "label": "âœˆï¸ Flight"}
        ],
        "context": f"Planning trip to {state.get('destination', 'destination')}"
    }
    
    # PAUSE and wait for user
    answer = interrupt(question)
    
    # This runs after user responds
    return {
        "travel_mode": answer,
        "messages": [f"Travel mode selected: {answer}"]
    }


CODE EXAMPLE - FASTAPI ENDPOINT:
-------------------------------
@router.post("/solo-trip")
async def solo_trip_planner(request: SoloTripRequest):
    """
    Handles both starting and resuming conversations
    """
    thread_id = request.thread_id or str(uuid.uuid4())
    config = {"configurable": {"thread_id": thread_id}}
    
    if request.resume_value:
        # RESUMING - user provided answer
        result = await asyncio.to_thread(
            solo_trip_graph.invoke,
            Command(resume=request.resume_value),
            config
        )
    else:
        # STARTING - new conversation
        result = await asyncio.to_thread(
            solo_trip_graph.invoke,
            {"query": request.query},
            config
        )
    
    # Check if workflow is paused (interrupt)
    if "__interrupt__" in result:
        return {
            "status": "waiting_for_input",
            "question": result["__interrupt__"][0].value,
            "thread_id": thread_id
        }
    
    # Workflow completed
    return {
        "status": "completed",
        "result": result,
        "thread_id": thread_id
    }

===================================================================================
                         CHAPTER 5: FRONTEND HANDLING
===================================================================================

CLIENT-SIDE FLOW:
----------------

1. User submits query
    fetch('/api/solo-trip', {
        method: 'POST',
        body: JSON.stringify({ query: "Plan trip to Manali" })
    })

2. Server returns question (interrupt)
    {
        "status": "waiting_for_input",
        "question": {
            "question": "How do you prefer to travel?",
            "options": [...]
        },
        "thread_id": "abc123"
    }

3. Show question UI to user

4. User clicks an option

5. Send answer with thread_id
    fetch('/api/solo-trip', {
        method: 'POST',
        body: JSON.stringify({
            resume_value: "car_ev",
            thread_id: "abc123"  // Same thread_id!
        })
    })

6. Repeat until completed

7. Final response
    {
        "status": "completed",
        "result": { ... full itinerary ... },
        "thread_id": "abc123"
    }


SAMPLE FRONTEND CODE:
--------------------
let currentThreadId = null;

async function startTrip(query) {
    const response = await fetch('/api/solo-trip', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query })
    });
    
    const data = await response.json();
    currentThreadId = data.thread_id;
    
    handleResponse(data);
}

async function submitAnswer(answer) {
    const response = await fetch('/api/solo-trip', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            resume_value: answer,
            thread_id: currentThreadId
        })
    });
    
    const data = await response.json();
    handleResponse(data);
}

function handleResponse(data) {
    if (data.status === 'waiting_for_input') {
        // Show question UI
        showQuestion(data.question);
    } else if (data.status === 'completed') {
        // Show final result
        showItinerary(data.result);
    }
}

===================================================================================
                         CHAPTER 6: ADVANCED PATTERNS
===================================================================================

PATTERN 1: Skip Questions Based on Context
-----------------------------------------
def ask_ev_charging(state: SoloTripState) -> dict:
    """Only ask about EV charging if user chose EV"""
    
    if state.get("travel_mode") != "car_ev":
        # Skip this question entirely
        return {"ev_charging_preference": None}
    
    # Ask only for EV users
    answer = interrupt({
        "question": "Do you need charging stops?",
        "options": ["Yes, plan charging stops", "No, short trip"]
    })
    
    return {"ev_charging_preference": answer}


PATTERN 2: Validation Before Continue
------------------------------------
def ask_budget_with_validation(state: SoloTripState) -> dict:
    while True:
        answer = interrupt({
            "question": "What's your daily budget in INR?",
            "type": "number"
        })
        
        try:
            budget = int(answer)
            if budget > 0:
                return {"budget": budget}
        except:
            pass
        
        # Invalid - will ask again
        # (Note: This is simplified, actual impl may differ)


PATTERN 3: Multi-Part Questions
------------------------------
def ask_trip_dates(state: SoloTripState) -> dict:
    # Ask start date
    start_date = interrupt({
        "question": "When do you want to start?",
        "type": "date"
    })
    
    # Ask end date
    end_date = interrupt({
        "question": "When do you want to return?",
        "type": "date"
    })
    
    return {
        "start_date": start_date,
        "end_date": end_date,
        "duration": calculate_days(start_date, end_date)
    }

===================================================================================
                         CHAPTER 7: DEBUGGING HITL
===================================================================================

COMMON ISSUES:

Issue 1: "Graph doesn't pause"
    Cause: interrupt() not called correctly
    Fix: Ensure interrupt() is CALLED, not just defined
    
    WRONG: def node(state): interrupt({"q": "?"})  # Missing return
    RIGHT: def node(state): answer = interrupt({"q": "?"}); return {...}

Issue 2: "Loses state on resume"
    Cause: Different thread_id or no checkpointer
    Fix: Ensure same thread_id, checkpointer is configured

Issue 3: "Answer goes to wrong node"
    Cause: Graph re-executes from start
    Fix: Use Command(resume=) not new invoke with query

DEBUG CHECKLIST:
---------------
â–¡ Checkpointer configured?
â–¡ Same thread_id for resume?
â–¡ Using Command(resume=) not new query?
â–¡ interrupt() returns a value?
â–¡ Node returns dict after interrupt()?

===================================================================================
                         CHAPTER 8: INTERVIEW ANSWERS
===================================================================================

Q: What is Human-in-the-Loop?
A: "HITL is a pattern where AI workflows pause to get human input.
    Instead of making assumptions, the AI asks questions, waits for
    answers, then uses those preferences to personalize the output."

Q: Why did you implement HITL in Solo Trip Planner?
A: "Solo trip planning is highly personal. The AI can't guess if
    someone prefers trains over flights, or vegan over non-veg food.
    HITL lets me collect 4 key preferences - travel mode, food,
    budget, accommodation - then generate a truly personalized plan."

Q: How does interrupt() work?
A: "When a node calls interrupt(question), LangGraph pauses the
    workflow and returns the question to the caller. The state is
    saved to MongoDB. When the user responds, we call Command(resume)
    with the answer, and the workflow continues from where it paused."

Q: How do you persist state across sessions?
A: "I use MongoDB checkpointing. LangGraph saves the complete state,
    current node position, and conversation history using a thread_id.
    When the user returns, even days later, we use the same thread_id
    to resume exactly where they left off."

Q: What's the difference between thread_id and session?
A: "thread_id is specific to one conversation. A user could have
    multiple trip plans (multiple thread_ids) in one browser session.
    Each thread_id maintains its own state independently."

===================================================================================
                              KEY TAKEAWAYS
===================================================================================

1. HITL = Pause AI â†’ Get human input â†’ Continue
2. interrupt(question) = Pause and return question
3. Command(resume=answer) = Continue with answer
4. MongoDB checkpointing = Persist state across sessions
5. thread_id = Unique identifier for each conversation
6. Always use SAME thread_id when resuming

REMEMBER: HITL makes AI collaborative, not autonomous.
          The human stays in control of personalization.

===================================================================================

